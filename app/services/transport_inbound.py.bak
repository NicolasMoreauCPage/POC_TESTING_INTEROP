# app/services/transport_inbound.py
from datetime import datetime
from typing import Dict, List, Optional, Tuple
import logging

from sqlmodel import Session, select

from app.models_endpoints import MessageLog
from app.services.mllp import parse_msh_fields, build_ack
from app.models import Patient, Dossier, Venue, Mouvement
from app.models_identifiers import Identifier, IdentifierType
from app.db import get_next_sequence
from app.services.emit_on_create import emit_to_senders
from app.services.identifier_manager import (
    create_identifier_from_hl7,
    merge_identifiers,
    get_main_identifier
)
from app.services.z99_handler import parse_z99, validate_z99_updates
from app.services.message_router import IHEMessageRouter
from app.state_transitions import is_valid_transition

logger = logging.getLogger("transport_inbound")


def _parse_patient_identifiers(pid_segment: str) -> List[Tuple[str, str]]:
    """Parse les identifiants patients du segment PID"""
    identifiers = []
    try:
        parts = pid_segment.split("|")
        if len(parts) <= 3:
            return []
            
        # PID-3 contient une liste d'identifiants séparés par ~
        id_list = parts[3].split("~")
        for cx in id_list:
            if not cx:
                continue
            # Détecter le type d'identifiant
            id_type = "PI"  # Par défaut Patient Internal
            if "^" in cx:
                cx_parts = cx.split("^")
                if len(cx_parts) > 4:
                    id_type = cx_parts[4]
            identifiers.append((cx, id_type))
            
    except Exception as e:
        logger.error(f"Erreur parsing identifiants PID: {str(e)}")
        
    return identifiers


def _parse_pid(message: str) -> dict:
    """Parse le segment PID avec support complet des identifiants"""
    out = {
        "identifiers": [],
        "family": "",
        "given": "",
        "middle": None,
        "prefix": None,
        "suffix": None,
        "birth_date": None,
        "gender": None,
        "address": None,
        "city": None,
        "state": None,
        "postal_code": None,
        "phone": None,
        "email": None,
        "ssn": None,
        "marital_status": None
    }
    
    try:
        lines = message.split("\r")
        pid = next((l for l in lines if l.startswith("PID")), None)
        if not pid:
            return out
            
        parts = pid.split("|")
        
        # Identifiants (PID-3)
        out["identifiers"] = _parse_patient_identifiers(pid)
        
        # Nom (PID-5)
        if len(parts) > 5 and parts[5]:
            name_parts = parts[5].split("^")
            out["family"] = name_parts[0] if len(name_parts) > 0 else ""
            out["given"] = name_parts[1] if len(name_parts) > 1 else ""
            out["middle"] = name_parts[2] if len(name_parts) > 2 else None
            out["prefix"] = name_parts[4] if len(name_parts) > 4 else None
            out["suffix"] = name_parts[3] if len(name_parts) > 3 else None
                
        # Date naissance (PID-7)
        if len(parts) > 7 and parts[7]:
            try:
                out["birth_date"] = datetime.strptime(parts[7], "%Y%m%d")
            except ValueError:
                pass
                
        # Genre (PID-8)
        if len(parts) > 8:
            out["gender"] = parts[8]
            
        # Adresse (PID-11)
        if len(parts) > 11 and parts[11]:
            addr_parts = parts[11].split("^")
            out["address"] = addr_parts[0] if len(addr_parts) > 0 else None
            out["city"] = addr_parts[2] if len(addr_parts) > 2 else None
            out["state"] = addr_parts[3] if len(addr_parts) > 3 else None
            out["postal_code"] = addr_parts[4] if len(addr_parts) > 4 else None
            
        # Téléphone (PID-13)
        if len(parts) > 13 and parts[13]:
            out["phone"] = parts[13].split("^")[0]
            
        # SSN et autres (PID-19, PID-16)
        if len(parts) > 19 and parts[19]:
            out["ssn"] = parts[19]
        if len(parts) > 16 and parts[16]:
            out["marital_status"] = parts[16]
            
    except Exception as e:
        logger.error(f"Erreur parsing PID: {str(e)}")
        
    return out


def _parse_pd1(message: str) -> dict:
    """Parse PD1 segment for a couple of useful POC fields.
    Returns dict with keys: primary_care_provider, religion, language
    PD1 is optional; be tolerant.
    """
    out = {"primary_care_provider": None, "religion": None, "language": None}
    try:
        lines = message.split("\r")
        pd1 = next((l for l in lines if l.startswith("PD1")), None)
        if not pd1:
            return out
        parts = pd1.split("|")
        # PD1-3 = patient primary care provider
        if len(parts) > 3 and parts[3]:
            out["primary_care_provider"] = parts[3].split("^")[0]
        # PD1-2 = living arrangement (not used) ; religion sometimes in PID but check PD1-4
        if len(parts) > 4 and parts[4]:
            out["religion"] = parts[4]
        # PD1-6 or PD1-7 may contain language; be tolerant and check PD1-6
        if len(parts) > 6 and parts[6]:
            out["language"] = parts[6]
    except Exception:
        pass
    return out


def _parse_hl7_datetime(s: Optional[str]) -> Optional[datetime]:
    if not s:
        return None
    s = s.strip()
    # common HL7 formats: YYYYMMDDHHMMSS or YYYYMMDD
    for fmt in ("%Y%m%d%H%M%S", "%Y%m%d%H%M", "%Y%m%d"):
        try:
            return datetime.strptime(s[: len(fmt.replace('%', '')) + 6], fmt)
        except Exception:
            try:
                return datetime.strptime(s, fmt)
            except Exception:
                continue
    # fallback: ignore timezone/extra and try first 14 chars
    try:
        return datetime.strptime(s[:14], "%Y%m%d%H%M%S")
    except Exception:
        return None


def _parse_pv1(message: str) -> dict:
    """Extract a few PV1 fields we need: location, hospital_service, admit/discharge datetimes, patient_class."""
    out = {"location": "", "hospital_service": "", "admit_time": None, "discharge_time": None, "patient_class": ""}
    try:
        lines = message.split("\r")
        pv1 = next((l for l in lines if l.startswith("PV1")), None)
        if not pv1:
            return out
        parts = pv1.split("|")
        # PV1 fields commonly: 2=patient class, 3=assigned patient location, 10=hospital service
        if len(parts) > 2 and parts[2]:
            out["patient_class"] = parts[2]
        if len(parts) > 3 and parts[3]:
            out["location"] = parts[3]
        if len(parts) > 10 and parts[10]:
            out["hospital_service"] = parts[10]
        # admit/discharge times
        if len(parts) > 44 and parts[44]:
            out["admit_time"] = _parse_hl7_datetime(parts[44])
        if len(parts) > 45 and parts[45]:
            out["discharge_time"] = _parse_hl7_datetime(parts[45])
    except Exception:
        pass
    return out


def _handle_z99_updates(message: str, session) -> None:
    """Look for Z99 segments with simple structured updates.

    Supported pattern (POC): Z99|Entity|seq|field|value
    where Entity in (Dossier, Venue, Mouvement)
    """
    try:
        lines = message.split("\r")
        for seg in [l for l in lines if l.startswith("Z99")]:
            parts = seg.split("|")
            if len(parts) < 4:
                continue
            entity = parts[1]
            seq = parts[2] if len(parts) > 2 else None
            field = parts[3] if len(parts) > 3 else None
            value = parts[4] if len(parts) > 4 else None
            if not entity or not seq:
                continue
            try:
                sid = int(seq)
            except Exception:
                continue
            if entity.lower().startswith("doss"):
                obj = session.exec(select(Dossier).where(Dossier.dossier_seq == sid)).first()
            elif entity.lower().startswith("ven"):
                obj = session.exec(select(Venue).where(Venue.venue_seq == sid)).first()
            elif entity.lower().startswith("mouv") or entity.lower().startswith("mvt"):
                obj = session.exec(select(Mouvement).where(Mouvement.mouvement_seq == sid)).first()
            else:
                obj = None
            if obj and field and value is not None:
                # apply if attribute exists
                if hasattr(obj, field):
                    setattr(obj, field, value)
                    session.add(obj)
                    session.commit()
    except Exception:
        logger.exception("Error handling Z99 updates")


async def on_message_inbound(msg: str, session, endpoint) -> str:
    """
    Point d'entrée principal pour les messages HL7v2 IHE PAM entrants.
    Gère les messages IHE PAM et leurs annulations selon IHE ITI-30/31.

    Messages supportés :
    Admission/Registration :
    - A01/A11 : Admission/Cancellation
    - A04/A23 : Register Patient/Delete Registration
    - A05/A38 : Pre-admit/Cancel pre-admission
    - A06/A07 : Change patient type

    Patient Movement :
    - A02/A12 : Patient transfer/Cancel transfer
    - A21/A52 : Leave/Cancel leave 
    - A22/A53 : Return from leave/Cancel return

    Discharge :
    - A03/A13 : Discharge/Cancel discharge

    Other :
    - A54/A55 : Change attending doctor/Cancel
    - Z99 : Partial updates (FR extension)

    Arguments:
        msg: Message HL7v2 déframé
        session: Session SQLModel fournie par session_factory()
        endpoint: Point de terminaison source
    
    Returns:
        Message ACK formaté HL7v2
    """
    try:
        try:
            # Parser le message
            f = parse_msh_fields(msg)
            ctrl_id = f.get("control_id", "")

        # Basic MSH-9 validation
        if not f.get("msg_type"):
            ack_code, text = "AE", "Missing/invalid MSH-9"
        else:
            ack_code, text = ("AA", "Message received") if ctrl_id else ("AE", "Missing MSH-10")

        # Si l'ACK est OK, traiter le message selon son type
        if ack_code == "AA":
            comp = f.get("msg_type", "").split("^")
            msg_family = comp[0] if len(comp) > 0 else ""
            trigger = comp[1] if len(comp) > 1 else ""

            # Ne traiter que les messages ADT
            if msg_family == "ADT":
                try:
                    # Commencer une transaction atomique 
                    with session.begin():
                                        # Log initial et tentative de traitement IHE PAM
                        log = MessageLog(
                            message_id=f.get("message_id", ""),
                            message_type=f"{msg_family}^{trigger}",
                            direction="IN", 
                            kind="MLLP",
                            endpoint_id=endpoint.id if endpoint else None,
                            correlation_id=ctrl_id or "",
                            payload=msg,
                            status="processing",
                            created_at=datetime.utcnow()
                        )
                        session.add(log)
                        
                        # Traitement IHE PAM
                        router = IHEMessageRouter()
                        if trigger in router.HANDLERS:
                            handler_type, handler = router.HANDLERS[trigger]
                            try:
                                result = handler(msg, session, endpoint)
                                if result:
                                    log.status = "processed"
                                    log.ack_payload = result 
                                    text = f"Message {trigger} traité avec succès"
                                    ack = result
                                else:
                                    log.status = "error"
                                    text = "Handler returned no result"
                                    ack_code = "AE"
                                    ack = build_ack(msg, ack_code=ack_code, text=text)
                                    log.ack_payload = ack
                            except Exception as e:
                                log.status = "error"
                                text = f"Error in message handler: {str(e)[:80]}"
                                ack_code = "AE"
                                ack = build_ack(msg, ack_code=ack_code, text=text)
                                log.ack_payload = ack
                                logger.error(f"Error in {trigger} handler: {str(e)}", exc_info=True)
                                raise
                        else:
                            log.status = "error"
                            text = f"No handler registered for {trigger}"
                            ack_code = "AE"
                            ack = build_ack(msg, ack_code=ack_code, text=text)
                            log.ack_payload = ack
                            logger.warning(f"No handler found for trigger {trigger}")
                        
                        # Router vers le handler approprié via IHEMessageRouter
                        router = IHEMessageRouter()
                        if trigger in router.HANDLERS:
                            try:
                                handler_type, handler = router.HANDLERS[trigger]
                                result = handler(msg, session, endpoint)
                                if result:
                                    msg_log.status = "processed"
                                    msg_log.ack_payload = result
                                else:
                                    msg_log.status = "error"
                                    msg_log.ack_payload = "Handler returned no result"
                            except Exception as e:
                                msg_log.status = "error"
                                msg_log.ack_payload = str(e)
                                logger.error(f"Error in message handler: {str(e)}")
                                raise

                    # parse PV1 for dossier/venue/mouvement mapping
                    pv1 = _parse_pv1(msg)

                    # --- Dossier & Venue (A01/A04/A05) ---
                    dossier_obj = None
                    venue_obj = None
                    if msg_family == "ADT" and trigger in ("A01", "A04", "A05"):
                        # find patient
                        patient_obj = None
                        if pid.get("external_id"):
                            patient_obj = session.exec(
                                select(Patient).where(Patient.external_id == pid["external_id"])
                            ).first()
                        if not patient_obj:
                            logger.warning("No patient found for Dossier creation; skipping Dossier/Venue creation")
                        else:
                            if pv1.get("admit_time"):
                                dossier_obj = session.exec(
                                    select(Dossier).where(
                                        Dossier.patient_id == patient_obj.id,
                                        Dossier.admit_time == pv1.get("admit_time")
                                    )
                                ).first()
                            if not dossier_obj:
                                dseq = get_next_sequence(session, "dossier")
                                dossier_obj = Dossier(
                                    dossier_seq=dseq,
                                    patient_id=patient_obj.id,
                                    uf_responsabilite=pv1.get("hospital_service") or pv1.get("location") or "",
                                    admit_time=pv1.get("admit_time") or datetime.utcnow(),
                                    discharge_time=pv1.get("discharge_time"),
                                )
                                session.add(dossier_obj)
                                session.flush()
                                session.refresh(dossier_obj)
                                logger.info(f"Created Dossier id={dossier_obj.id} seq={dossier_obj.dossier_seq}")

                            # Venue
                            if dossier_obj:
                                if pv1.get("admit_time"):
                                    venue_obj = session.exec(
                                        select(Venue).where(
                                            Venue.dossier_id == dossier_obj.id,
                                            Venue.start_time == pv1.get("admit_time")
                                        )
                                    ).first()
                                if not venue_obj:
                                    vseq = get_next_sequence(session, "venue")
                                    venue_obj = Venue(
                                        venue_seq=vseq,
                                        dossier_id=dossier_obj.id,
                                        uf_responsabilite=dossier_obj.uf_responsabilite,
                                        start_time=pv1.get("admit_time") or dossier_obj.admit_time,
                                        code=(pv1.get("location") or "")[:64],
                                        label=(pv1.get("location") or ""),
                                    )
                                    session.add(venue_obj)
                                    session.flush()
                                    session.refresh(venue_obj)
                                    logger.info(f"Created Venue id={venue_obj.id} seq={venue_obj.venue_seq}")

                    # --- Movements (A01,A04,A06,A02,A21,A22,A54) ---
                    movement_triggers = ("A01", "A04", "A06", "A02", "A21", "A22", "A54")
                    if msg_family == "ADT" and trigger in movement_triggers:
                        # ensure we have a venue to attach to
                        if not venue_obj:
                            # try to find a venue for this patient and admit_time
                            if pid.get("external_id"):
                                patient_obj = session.exec(
                                    select(Patient).where(Patient.external_id == pid["external_id"])
                                ).first()
                                if patient_obj and pv1.get("admit_time"):
                                    d = session.exec(
                                        select(Dossier).where(Dossier.patient_id == patient_obj.id, Dossier.admit_time == pv1.get("admit_time"))
                                    ).first()
                                    if d:
                                        venue_obj = session.exec(
                                            select(Venue).where(Venue.dossier_id == d.id, Venue.start_time == pv1.get("admit_time"))
                                        ).first()
                        if not venue_obj:
                            # fallback: create minimal venue linked to dossier if any
                            dossier_for_venue = None
                            if pid.get("external_id"):
                                patient_obj = session.exec(
                                    select(Patient).where(Patient.external_id == pid["external_id"])
                                ).first()
                                if patient_obj:
                                    dossier_for_venue = session.exec(
                                        select(Dossier).where(Dossier.patient_id == patient_obj.id).order_by(Dossier.id.desc())
                                    ).first()
                            if dossier_for_venue:
                                vseq = get_next_sequence(session, "venue")
                                venue_obj = Venue(
                                    venue_seq=vseq,
                                    dossier_id=dossier_for_venue.id,
                                    uf_responsabilite=dossier_for_venue.uf_responsabilite,
                                    start_time=pv1.get("admit_time") or datetime.utcnow(),
                                )
                                session.add(venue_obj)
                                session.flush()
                                session.refresh(venue_obj)
                        if venue_obj:
                            mseq = get_next_sequence(session, "mouvement")
                            mv = Mouvement(
                                mouvement_seq=mseq,
                                venue_id=venue_obj.id,
                                type=trigger,
                                when=pv1.get("admit_time") or datetime.utcnow(),
                                location=pv1.get("location"),
                            )
                            session.add(mv)
                            session.flush()
                            session.refresh(mv)
                            logger.info(f"Created Mouvement id={mv.id} seq={mv.mouvement_seq} on venue={venue_obj.id}")

                    # --- Z99 handling (modifications) ---
                    _handle_z99_updates(msg, session)

                    # MessageLog is created inside the same transaction so the whole processing is atomic
                    log = MessageLog(
                        direction="in",
                        kind="MLLP",
                        endpoint_id=(getattr(endpoint, "id", None)),
                        correlation_id=ctrl_id or "",
                        status="ack_ok",
                        payload=msg,
                        ack_payload="",
                        created_at=datetime.utcnow(),
                    )
                    session.add(log)

                    # commit happens automatically on successful exit of session.begin()
            except Exception as e:
                # rollback occurred; log error and return AE
                logger.exception(f"Persistence error: {e}")
                # best-effort: write error MessageLog entry
                try:
                    err_ack = build_ack(msg, ack_code="AE", text=str(e)[:80])
                    log = MessageLog(
                        direction="in",
                        kind="MLLP",
                        endpoint_id=(getattr(endpoint, "id", None)),
                        correlation_id=ctrl_id or "",
                        status="error",
                        payload=msg,
                        ack_payload=err_ack,
                        created_at=datetime.utcnow()
                    )
                    session.add(log)
                    session.commit()
                    return err_ack
                except Exception:
                    logger.exception("Failed to write error MessageLog")
                    return build_ack(msg, ack_code="AE", text=str(e)[:80])

            # Message traité avec succès ou erreur sans exception
            ack = build_ack(msg, ack_code=ack_code, text=text)
            try:
                # Ensure final message state is logged
                if log:
                    log.ack_payload = ack
                    session.commit()
            except Exception:
                logger.exception("Failed to update MessageLog ACK")
            
            return ack    except Exception as e:
        # En cas d'erreur globale, tenter un ACK générique AE
        logger.exception(f"Erreur non gérée dans on_message_inbound: {e}")
        ack = build_ack(msg, ack_code="AE", text=f"Erreur non gérée: {str(e)[:80]}")
        try:
            log = MessageLog(
                direction="in",
                kind="MLLP",
                endpoint_id=(getattr(endpoint, "id", None)),
                correlation_id=ctrl_id or "",
                status="error",
                payload=msg,
                ack_payload=ack,
                created_at=datetime.utcnow()
            )
            session.add(log)
            session.commit()
        except Exception:
            logger.exception("Échec de l'écriture du MessageLog d'erreur")
        return ack
